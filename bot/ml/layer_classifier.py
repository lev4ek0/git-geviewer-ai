from tenacity import retry, stop_after_attempt
from typing import List, Dict
from pathlib import Path
import json
import re

from langchain_core.output_parsers import StrOutputParser, BaseOutputParser
from langchain_core.prompts import PromptTemplate

from files_parser import FilesParser
from llms import LLMFactory


DATA_PATH = r"D:\ITMO\hacks\llm_review\test_project"


LAYER_CLASSIFIER_PROMPT = """
## System prompt
Ты помощник в ревью кода. Ты отвечаешь только на русском языке.

## Твоя задача
Тебе на вход приходит структура проекта PROJECT в виде словаря Python, где ключи - путь до директории, а значения - список скриптов `.py`.
Этот проект должен соответствовать "Гексагональной" архитектуре.
Твоя задача классифицировать каждую директорию (ключи словаря) на один из НЕСКОЛЬКИХ классов.
Для этого используй представление о том как должен выглядеть гексагональный проект, имена директорий и файлов. Примерно представь что может в них находится для успешной
классификации.

## Описание классов
1. **core**
**Ключевые признаки**:
- Содержит доменные сущности, бизнес-правила, DTO, ошибки и сервисы.
- Не зависит от внешних интеграций и инфраструктуры.
- Работает только с интерфейсами для взаимодействия с адаптерами (репозитории, шлюзы, API-клиенты).
- Сущности описывают поведение и инварианты, а не только данные.
- Для передачи данных между слоями используются DTO, а не примитивные структуры (словари, списки и т. д.).
- Код, связанный с анализом данных (feature engineering и моделями), выделяется в отдельные пакеты в core.
- Выполняется валидация данных через pydantic-модели при вызове методов сервисов.
**Основные роли**:
- Управление и реализация бизнес-логики.
- Хранение доменных знаний и правил.
- Описание ошибок и валидации данных.
- Предоставление интерфейсов для работы с данными (реализуются в адаптерах).
**Примеры компонентов**:
- Сервисы (например, UserService для управления пользователями).
- Доменные сущности (например, User, содержащий поведение и бизнес-правила).
- DTO (например, UserDTO для передачи данных).
- Интерфейсы репозиториев (UserRepository).
2. **adapters**
**Ключевые признаки**:
- Это слой интеграций со всем внешним миром.
- Реализует интерфейсы, описанные в core (репозитории, шлюзы, API-клиенты).
- Содержит код для работы с базами данных, внешними API, очередями, веб-серверами и т. д.
- Может содержать адаптеры для взаимодействия с пользовательскими интерфейсами (например, веб-контроллеры, CLI).
- Бизнес-логика не реализуется в адаптерах — только инфраструктурные задачи.
- В сложных проектах возвращаются ORM-объекты; в простых — DTO.
**Основные роли**:
- Реализация интерфейсов, описанных в core.
- Интеграция с внешними системами (базы данных, API, очереди).
- Предоставление данных для использования в core.
**Примеры компонентов**:
- Реализации репозиториев (SQLUserRepository, работающий с базой данных).
- Веб-контроллеры (UserController).
- Консьюмеры и продьюсеры очередей.
- API-клиенты для внешних систем.
- Таблицы баз данных, описанные через ORM.
3. **composite**
**Ключевые признаки**:
- Отвечает за сборку, настройку и запуск приложения.
- Выполняет внедрение зависимостей (DI) для всех слоев.
- Собирает инфраструктурные компоненты, сервисы и адаптеры в единую систему.
- Настраивает параметры и конфигурации приложения.
- Передает зависимости (например, репозитории, сервисы) в адаптеры (например, HTTP API).
**Основные роли**:
- Инициализация приложения.
- Настройка и внедрение всех зависимостей.
- Управление жизненным циклом приложения.
**Примеры компонентов**:
- Инициализация подключения к базе данных (например, sqlalchemy engine).
- Регистрация компонентов веб-приложения (например, контроллеров).
- Сборка и передача зависимостей в адаптеры.
- Запуск HTTP-сервера (например, через gunicorn).
4. **tests**
Модули для тестирования приложения. unit тесты и интеграционные тесты.

## Формат вывода
ОБЯЗАТЕЛЬНО выдай ответ в виде JSON где ключи - путь до директории (НЕ ФАЙЛА!), а значения - результат классификации
с указанием класса.

**Пример ответа**:
PROJECT:
{{
    ".": ["services.py"],
    "alembic/api": ["alembic.py", "env.py"],
    "runners": ["cli.py"],
}}
Твой ответ:
```json
{{
    ".": "core",
    "alembic/api": "adapters",
    "runners": "composite"
}}
```

Формат вывода:
```json
<Твой ответ>
```

PROJECT:
{project}
Твой ответ:
"""


class LayerClassifier:
    def __init__(self, llm, prompt: str = LAYER_CLASSIFIER_PROMPT, output_parser: BaseOutputParser = StrOutputParser()):
        self._chain = PromptTemplate.from_template(prompt) | llm | output_parser

    @retry(stop=stop_after_attempt(3))
    def invoke(self, project_structure: Dict[str, List[str]]) -> Dict:
        template = {str(k): v for k, v in project_structure.items()}
        answer = self._chain.invoke({"project": template})
        answer_json = json.loads(re.findall(r"```json\n(.*)\n```", answer, re.DOTALL)[0])
        return {Path(k): v for k, v in answer_json.items()}


if __name__ == "__main__":
    llm = LLMFactory.get_llm("Qwen/Qwen2.5-Coder-32B-Instruct")

    classifier = LayerClassifier(llm, LAYER_CLASSIFIER_PROMPT, StrOutputParser())
    project_structure = FilesParser().invoke(DATA_PATH)

    print(classifier.invoke(project_structure))
